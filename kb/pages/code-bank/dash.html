<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dash - VG101 Knowledge Base</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Lora:ital,wght@0,400;0,500;1,400&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../css/style.css">
  <style>
    .register{margin:2rem 0;border-radius:8px;overflow:hidden}
    .register-header{padding:1rem 1.5rem;font-weight:600;font-size:.875rem;text-transform:uppercase;letter-spacing:.05em;cursor:pointer;display:flex;justify-content:space-between;align-items:center}
    .register-header::after{content:'▼';font-size:.75rem;transition:transform .2s}
    .register.collapsed .register-header::after{transform:rotate(-90deg)}
    .register-content{padding:1.5rem;border-top:1px solid rgba(0,0,0,0.1)}
    .register.collapsed .register-content{display:none}
    .register--practice{background:#f0fdfa;border:2px solid #14b8a6}
    .register--practice .register-header{background:#14b8a6;color:#fff}
    .register--practice .register-content{border-color:#99f6e4}
    .register--craft{background:#eff6ff;border:2px solid #3b82f6}
    .register--craft .register-header{background:#3b82f6;color:#fff}
    .register--craft .register-content{border-color:#bfdbfe}
    .register--theory{background:#faf5ff;border:2px solid #a855f7}
    .register--theory .register-header{background:#a855f7;color:#fff}
    .register--theory .register-content{border-color:#e9d5ff}
    .register-content h3{margin-top:0}
    .register-content h3:not(:first-child){margin-top:1.5rem}
    .register-label{font-size:.75rem;opacity:.8;font-weight:400;text-transform:none;letter-spacing:normal}
    .term{color:#f59e0b;text-decoration:underline;text-decoration-style:dotted;text-underline-offset:2px}
    .term:hover{color:#d97706}
  </style>
</head>
<body>
  <div class="site-container">
    <nav class="sidebar">
      <a href="../../../index.html" class="site-title">← marty64.net</a>
      <p class="site-subtitle">VG101 Knowledge Base</p>

      <a href="../../index.html" class="nav-home">← VG101 Home</a>

      <div class="nav-section">
        <div class="nav-section-title">Core Framework</div>
        <ul class="nav-list">
          <li class="nav-item"><a href="../framework/gesture.html" class="nav-link">Gesture</a></li>
          <li class="nav-item"><a href="../framework/the-four-as.html" class="nav-link">The 4 A's</a></li>
          <li class="nav-item"><a href="../framework/aesthetic-heritage.html" class="nav-link">Aesthetic Heritage</a></li>
          <li class="nav-item"><a href="../framework/permissions.html" class="nav-link">Permissions</a></li>
        </ul>
      </div>

      <div class="nav-section">
        <div class="nav-section-title">Foundations</div>
        <ul class="nav-list">
          <li class="nav-item"><a href="../foundations/what-makes-a-videogame.html" class="nav-link">What Makes a Videogame</a></li>
          <li class="nav-item"><a href="../foundations/the-weekly-rhythm.html" class="nav-link">The Weekly Rhythm</a></li>
          <li class="nav-item"><a href="../foundations/player-psychology.html" class="nav-link">Player Psychology</a></li>
          <li class="nav-item"><a href="../foundations/the-design-lens.html" class="nav-link">The Design Lens</a></li>
        </ul>
      </div>

      <div class="nav-section">
        <div class="nav-section-title">Code Bank</div>
        <ul class="nav-list">
          <li class="nav-item"><a href="index.html" class="nav-link">Overview</a></li>
          <li class="nav-item"><a href="basic-jump.html" class="nav-link">Basic Jump</a></li>
          <li class="nav-item"><a href="variable-jump.html" class="nav-link">Variable Jump</a></li>
          <li class="nav-item"><a href="dash.html" class="nav-link active">Dash</a></li>
          <li class="nav-item"><a href="screen-shake.html" class="nav-link">Screen Shake</a></li>
        </ul>
      </div>

      <div class="nav-section">
        <div class="nav-section-title">Resources</div>
        <ul class="nav-list">
          <li class="nav-item"><a href="../case-studies/index.html" class="nav-link">Case Studies</a></li>
          <li class="nav-item"><a href="../glossary.html" class="nav-link">Glossary</a></li>
          <li class="nav-item"><a href="../references.html" class="nav-link">References</a></li>
        </ul>
      </div>
    </nav>

    <main class="main-content">
      <div class="content-wrapper">
        <nav class="breadcrumb">
          <a href="../../index.html">VG101</a> / <a href="index.html">Code Bank</a> / Dash
        </nav>

        <h1>Dash</h1>

        <p class="lead">
          A burst of movement in a direction. Quick, committed, often with invincibility. The defining gesture of modern action platformers.
        </p>

        <!-- PRACTICE REGISTER -->
        <div class="register register--practice">
          <div class="register-header" onclick="this.parentElement.classList.toggle('collapsed')">
            Practice <span class="register-label">- what you do</span>
          </div>
          <div class="register-content">
            <h3>The Feel</h3>
            <p>Dash is <strong>explosive and committed</strong>. You press, you move, no take-backs. The commitment creates tension; the burst creates power.</p>

            <h3>Exposed Variables</h3>
            <table>
              <thead>
                <tr>
                  <th>Variable</th>
                  <th>Type</th>
                  <th>Default</th>
                  <th>What it does</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>dashSpeed</code></td>
                  <td>float</td>
                  <td>25.0</td>
                  <td>How fast you move during dash</td>
                </tr>
                <tr>
                  <td><code>dashDuration</code></td>
                  <td>float</td>
                  <td>0.15</td>
                  <td>How long the dash lasts (seconds)</td>
                </tr>
                <tr>
                  <td><code>dashCooldown</code></td>
                  <td>float</td>
                  <td>0.0</td>
                  <td>Time before you can dash again</td>
                </tr>
                <tr>
                  <td><code>dashDirection</code></td>
                  <td>enum</td>
                  <td>EightWay</td>
                  <td>Which directions are valid</td>
                </tr>
                <tr>
                  <td><code>dashCount</code></td>
                  <td>int</td>
                  <td>1</td>
                  <td>Dashes available per air period</td>
                </tr>
                <tr>
                  <td><code>refreshOnGround</code></td>
                  <td>bool</td>
                  <td>true</td>
                  <td>Does landing restore dash?</td>
                </tr>
                <tr>
                  <td><code>invincibleDuringDash</code></td>
                  <td>bool</td>
                  <td>false</td>
                  <td>Ignore damage while dashing?</td>
                </tr>
                <tr>
                  <td><code>cancelWindow</code></td>
                  <td>float</td>
                  <td>0.0</td>
                  <td>When can you cancel into other actions?</td>
                </tr>
                <tr>
                  <td><code>momentumTransfer</code></td>
                  <td>float</td>
                  <td>0.0</td>
                  <td>How much dash speed carries into normal movement</td>
                </tr>
              </tbody>
            </table>

            <h3>Tuning Guide</h3>

            <p><strong>Celeste-style (precise, resource-based):</strong></p>
            <ul>
              <li><code>dashSpeed</code>: 25</li>
              <li><code>dashDuration</code>: 0.12-0.15</li>
              <li><code>dashCount</code>: 1</li>
              <li><code>dashDirection</code>: EightWay</li>
              <li><code>refreshOnGround</code>: true</li>
              <li><code>invincibleDuringDash</code>: true (brief)</li>
              <li><code>momentumTransfer</code>: 0</li>
            </ul>
            <p><em>One dash per airtime, eight directions, full commitment</em></p>

            <p><strong>Hades-style (combat, spammable):</strong></p>
            <ul>
              <li><code>dashSpeed</code>: 18</li>
              <li><code>dashDuration</code>: 0.1</li>
              <li><code>dashCooldown</code>: 0.3</li>
              <li><code>dashCount</code>: unlimited (via cooldown)</li>
              <li><code>dashDirection</code>: EightWay</li>
              <li><code>invincibleDuringDash</code>: true</li>
              <li><code>cancelWindow</code>: 0.05</li>
            </ul>
            <p><em>Faster, shorter dashes you can chain</em></p>

            <p><strong>Mega Man X-style (ground only, forward):</strong></p>
            <ul>
              <li><code>dashSpeed</code>: 15</li>
              <li><code>dashDuration</code>: 0.3</li>
              <li><code>dashDirection</code>: Horizontal</li>
              <li><code>dashCooldown</code>: 0</li>
              <li><code>groundOnly</code>: true (separate variable)</li>
            </ul>
            <p><em>Longer duration, ground-based</em></p>

            <h3>Pseudocode</h3>
            <pre><code>On Dash Press (if dashCount > 0):
  - Record dash direction from input
  - Set dash state
  - Start dash timer
  - If invincible: enable invincibility frames

During Dash:
  - Override normal movement with dashSpeed in dashDirection
  - Ignore gravity (optional)
  - Check for cancel window inputs

On Dash End:
  - Return to normal movement
  - Apply momentum transfer if any
  - Start cooldown timer if applicable
  - Decrement dashCount

On Ground Contact:
  - If refreshOnGround: restore dashCount</code></pre>

            <h3>Unity Setup (2D)</h3>
            <ol>
              <li><strong>Create Input Actions:</strong>
                <ul>
                  <li>Window → Input Actions (or open existing asset)</li>
                  <li>Create "Dash" action (Button type) - bind to Left Shift or Right Trigger</li>
                  <li>Create "Move" action (Value, Vector2) - bind to WASD/Arrows and Left Stick</li>
                  <li>Save and enable "Generate C# Class"</li>
                </ul>
              </li>
              <li><strong>Setup the Player:</strong>
                <ul>
                  <li>Add <code>Rigidbody2D</code> (Gravity Scale: 3, Freeze Rotation Z: checked)</li>
                  <li>Add <code>Collider2D</code> (BoxCollider2D or CapsuleCollider2D)</li>
                  <li>Add <code>PlayerInput</code> component, assign your Input Actions asset</li>
                  <li>Add the <code>Dash2D.cs</code> script below</li>
                </ul>
              </li>
              <li><strong>Create Ground Check:</strong>
                <ul>
                  <li>Create empty child object named "GroundCheck"</li>
                  <li>Position it at the player's feet</li>
                  <li>Assign to the script's <code>groundCheck</code> field</li>
                </ul>
              </li>
              <li><strong>Configure Layers:</strong>
                <ul>
                  <li>Edit → Project Settings → Tags and Layers</li>
                  <li>Create "Ground" layer, assign to ground objects</li>
                  <li>Set <code>groundLayer</code> in the script's Inspector</li>
                </ul>
              </li>
              <li><strong>Optional - Invincibility Setup:</strong>
                <ul>
                  <li>The script exposes <code>IsInvincible</code> property</li>
                  <li>Your damage system should check this before applying damage</li>
                </ul>
              </li>
            </ol>

            <h3>The Script (2D)</h3>
            <pre><code>// ============================================================
// Dash2D.cs
// A comprehensive 2D dash with direction options, resource
// management, invincibility, and momentum transfer.
// Unity 6.x + New Input System
// ============================================================

using UnityEngine;
using UnityEngine.InputSystem;

// Dash direction modes - how we determine which way to dash
public enum DashDirectionMode
{
    EightWay,       // All 8 cardinal + diagonal directions
    FourWay,        // Up, Down, Left, Right only
    Horizontal,     // Left and Right only
    FacingDirection // Dash the way the sprite is facing
}

[RequireComponent(typeof(Rigidbody2D))]
public class Dash2D : MonoBehaviour
{
    // ========================================================
    // DASH PARAMETERS - Tune these in the Inspector
    // ========================================================

    [Header("Dash Settings")]
    [Tooltip("How fast you move during dash (units/second)")]
    [SerializeField] [Range(10f, 50f)] private float dashSpeed = 25f;

    [Tooltip("How long the dash lasts (seconds)")]
    [SerializeField] [Range(0.05f, 0.5f)] private float dashDuration = 0.15f;

    [Tooltip("Time before you can dash again (0 = no cooldown)")]
    [SerializeField] [Range(0f, 2f)] private float dashCooldown = 0f;

    [Header("Direction Settings")]
    [Tooltip("Which directions are valid for dashing")]
    [SerializeField] private DashDirectionMode directionMode = DashDirectionMode.EightWay;

    [Tooltip("Default dash direction if no input (1 = right, -1 = left)")]
    [SerializeField] private int facingDirection = 1;

    [Header("Resource Management")]
    [Tooltip("How many dashes available per air period")]
    [SerializeField] [Range(1, 5)] private int maxDashCount = 1;

    [Tooltip("Does landing restore dash charges?")]
    [SerializeField] private bool refreshOnGround = true;

    [Header("Combat Options")]
    [Tooltip("Invincible (ignore damage) while dashing?")]
    [SerializeField] private bool invincibleDuringDash = false;

    [Tooltip("How much dash speed carries into normal movement (0-1)")]
    [SerializeField] [Range(0f, 1f)] private float momentumTransfer = 0f;

    [Header("Ground Detection")]
    [Tooltip("Empty transform at player's feet")]
    [SerializeField] private Transform groundCheck;

    [Tooltip("Radius of ground check circle")]
    [SerializeField] [Range(0.05f, 0.5f)] private float groundCheckRadius = 0.1f;

    [Tooltip("Which layers count as ground")]
    [SerializeField] private LayerMask groundLayer;

    [Header("Input Actions")]
    [Tooltip("Reference to your Input Actions asset")]
    [SerializeField] private InputActionAsset inputActions;

    [Header("Debug")]
    [Tooltip("Show debug info in console")]
    [SerializeField] private bool debugMode = false;

    // ========================================================
    // INTERNAL STATE - Don't modify directly
    // ========================================================

    private Rigidbody2D rb;
    private InputAction dashAction;
    private InputAction moveAction;

    // Dash state
    private bool isDashing = false;
    private float dashTimer = 0f;
    private float cooldownTimer = 0f;
    private int dashesRemaining;
    private Vector2 dashDirection;
    private float storedGravityScale;

    // Ground state
    private bool isGrounded = false;
    private bool wasGrounded = false;

    // ========================================================
    // PUBLIC PROPERTIES - For other scripts to read
    // ========================================================

    /// &lt;summary&gt;
    /// True while the player is actively dashing
    /// &lt;/summary&gt;
    public bool IsDashing =&gt; isDashing;

    /// &lt;summary&gt;
    /// True if the player is invincible (dashing + invincibility enabled)
    /// Use this in your damage system to check before applying damage
    /// &lt;/summary&gt;
    public bool IsInvincible =&gt; isDashing &amp;&amp; invincibleDuringDash;

    /// &lt;summary&gt;
    /// Current remaining dash charges
    /// &lt;/summary&gt;
    public int DashesRemaining =&gt; dashesRemaining;

    /// &lt;summary&gt;
    /// True if player can dash right now
    /// &lt;/summary&gt;
    public bool CanDash =&gt; !isDashing &amp;&amp;
                          dashesRemaining &gt; 0 &amp;&amp;
                          cooldownTimer &lt;= 0f;

    // ========================================================
    // UNITY LIFECYCLE
    // ========================================================

    void Awake()
    {
        // Get the Rigidbody2D component
        rb = GetComponent&lt;Rigidbody2D&gt;();
        storedGravityScale = rb.gravityScale;

        // Initialize dash charges
        dashesRemaining = maxDashCount;

        // Setup input actions
        if (inputActions != null)
        {
            var gameplay = inputActions.FindActionMap("Gameplay");
            if (gameplay != null)
            {
                dashAction = gameplay.FindAction("Dash");
                moveAction = gameplay.FindAction("Move");
            }
        }
    }

    void OnEnable()
    {
        // Enable input actions and subscribe to dash
        if (dashAction != null)
        {
            dashAction.Enable();
            dashAction.performed += OnDashPressed;
        }
        if (moveAction != null)
        {
            moveAction.Enable();
        }
    }

    void OnDisable()
    {
        // Unsubscribe to prevent memory leaks
        if (dashAction != null)
        {
            dashAction.performed -= OnDashPressed;
            dashAction.Disable();
        }
        if (moveAction != null)
        {
            moveAction.Disable();
        }
    }

    void Update()
    {
        // Update timers
        if (cooldownTimer &gt; 0f)
        {
            cooldownTimer -= Time.deltaTime;
        }

        // Check ground state for dash refresh
        CheckGroundState();
    }

    void FixedUpdate()
    {
        // Handle dash movement in FixedUpdate for physics consistency
        if (isDashing)
        {
            ProcessDash();
        }
    }

    // ========================================================
    // INPUT HANDLING
    // ========================================================

    /// &lt;summary&gt;
    /// Called when dash input is pressed
    /// &lt;/summary&gt;
    private void OnDashPressed(InputAction.CallbackContext context)
    {
        TryDash();
    }

    /// &lt;summary&gt;
    /// Attempt to initiate a dash
    /// &lt;/summary&gt;
    public void TryDash()
    {
        // Check if we can dash
        if (!CanDash)
        {
            if (debugMode)
            {
                if (isDashing) Debug.Log("Dash blocked: already dashing");
                else if (dashesRemaining &lt;= 0) Debug.Log("Dash blocked: no charges");
                else if (cooldownTimer &gt; 0) Debug.Log($"Dash blocked: cooldown ({cooldownTimer:F2}s)");
            }
            return;
        }

        // Determine dash direction based on mode
        dashDirection = CalculateDashDirection();

        // If no valid direction, don't dash
        if (dashDirection == Vector2.zero)
        {
            if (debugMode) Debug.Log("Dash blocked: no valid direction");
            return;
        }

        // Start the dash!
        StartDash();
    }

    // ========================================================
    // DIRECTION CALCULATION
    // ========================================================

    /// &lt;summary&gt;
    /// Calculate dash direction based on current mode and input
    /// &lt;/summary&gt;
    private Vector2 CalculateDashDirection()
    {
        Vector2 input = Vector2.zero;

        // Get raw input
        if (moveAction != null)
        {
            input = moveAction.ReadValue&lt;Vector2&gt;();
        }

        switch (directionMode)
        {
            case DashDirectionMode.EightWay:
                // Normalize 8-way diagonal input
                if (input.magnitude &gt; 0.1f)
                {
                    return input.normalized;
                }
                // Default to facing direction if no input
                return new Vector2(facingDirection, 0);

            case DashDirectionMode.FourWay:
                // Snap to nearest cardinal direction
                if (Mathf.Abs(input.x) &gt; Mathf.Abs(input.y))
                {
                    return new Vector2(Mathf.Sign(input.x), 0);
                }
                else if (Mathf.Abs(input.y) &gt; 0.1f)
                {
                    return new Vector2(0, Mathf.Sign(input.y));
                }
                return new Vector2(facingDirection, 0);

            case DashDirectionMode.Horizontal:
                // Only left/right
                if (Mathf.Abs(input.x) &gt; 0.1f)
                {
                    return new Vector2(Mathf.Sign(input.x), 0);
                }
                return new Vector2(facingDirection, 0);

            case DashDirectionMode.FacingDirection:
                // Always dash the way sprite is facing
                return new Vector2(facingDirection, 0);

            default:
                return new Vector2(facingDirection, 0);
        }
    }

    // ========================================================
    // DASH EXECUTION
    // ========================================================

    /// &lt;summary&gt;
    /// Begin the dash
    /// &lt;/summary&gt;
    private void StartDash()
    {
        isDashing = true;
        dashTimer = dashDuration;
        dashesRemaining--;

        // Disable gravity during dash
        storedGravityScale = rb.gravityScale;
        rb.gravityScale = 0f;

        // Set velocity to dash direction
        rb.linearVelocity = dashDirection * dashSpeed;

        if (debugMode)
        {
            Debug.Log($"Dash started! Direction: {dashDirection}, Charges left: {dashesRemaining}");
        }
    }

    /// &lt;summary&gt;
    /// Process ongoing dash (called in FixedUpdate)
    /// &lt;/summary&gt;
    private void ProcessDash()
    {
        dashTimer -= Time.fixedDeltaTime;

        // Keep dash velocity constant
        rb.linearVelocity = dashDirection * dashSpeed;

        // Check if dash is complete
        if (dashTimer &lt;= 0f)
        {
            EndDash();
        }
    }

    /// &lt;summary&gt;
    /// End the dash and return to normal state
    /// &lt;/summary&gt;
    private void EndDash()
    {
        isDashing = false;

        // Restore gravity
        rb.gravityScale = storedGravityScale;

        // Apply momentum transfer (0 = full stop, 1 = keep all speed)
        rb.linearVelocity *= momentumTransfer;

        // Start cooldown
        cooldownTimer = dashCooldown;

        if (debugMode)
        {
            Debug.Log($"Dash ended. Cooldown: {dashCooldown}s, Momentum kept: {momentumTransfer * 100}%");
        }
    }

    // ========================================================
    // GROUND DETECTION + DASH REFRESH
    // ========================================================

    /// &lt;summary&gt;
    /// Check if grounded and refresh dash if needed
    /// &lt;/summary&gt;
    private void CheckGroundState()
    {
        wasGrounded = isGrounded;

        // Check for ground
        if (groundCheck != null)
        {
            isGrounded = Physics2D.OverlapCircle(
                groundCheck.position,
                groundCheckRadius,
                groundLayer
            );
        }

        // Refresh dashes when landing
        if (refreshOnGround &amp;&amp; isGrounded &amp;&amp; !wasGrounded)
        {
            dashesRemaining = maxDashCount;

            if (debugMode)
            {
                Debug.Log("Landed! Dash charges refreshed.");
            }
        }
    }

    // ========================================================
    // PUBLIC METHODS - Call from other scripts
    // ========================================================

    /// &lt;summary&gt;
    /// Manually refresh dash charges (e.g., from power-up or special surface)
    /// &lt;/summary&gt;
    public void RefreshDashes()
    {
        dashesRemaining = maxDashCount;
    }

    /// &lt;summary&gt;
    /// Update facing direction (call this from your movement script)
    /// &lt;/summary&gt;
    public void SetFacingDirection(int direction)
    {
        facingDirection = direction &gt; 0 ? 1 : -1;
    }

    /// &lt;summary&gt;
    /// Force end the dash early (for wall collision, etc.)
    /// &lt;/summary&gt;
    public void CancelDash()
    {
        if (isDashing)
        {
            EndDash();
        }
    }

    // ========================================================
    // DEBUG VISUALIZATION
    // ========================================================

    void OnDrawGizmosSelected()
    {
        // Show ground check radius
        if (groundCheck != null)
        {
            Gizmos.color = Color.green;
            Gizmos.DrawWireSphere(groundCheck.position, groundCheckRadius);
        }

        // Show dash direction when selected
        if (isDashing)
        {
            Gizmos.color = Color.cyan;
            Gizmos.DrawRay(transform.position, dashDirection * 2f);
        }
    }
}

// ============================================================
// USAGE NOTES:
//
// 1. Assign Input Actions asset with "Gameplay" action map
//    containing "Dash" and "Move" actions
//
// 2. For invincibility, check IsInvincible in your damage code:
//    if (!player.GetComponent&lt;Dash2D&gt;().IsInvincible)
//    {
//        player.TakeDamage(amount);
//    }
//
// 3. To refresh dashes on special surfaces (like Celeste's
//    crystals), call RefreshDashes() from a trigger:
//    void OnTriggerEnter2D(Collider2D other)
//    {
//        other.GetComponent&lt;Dash2D&gt;()?.RefreshDashes();
//    }
//
// 4. Call SetFacingDirection() from your movement script
//    when the player turns around
//
// 5. For 3D: Change Rigidbody2D to Rigidbody, Physics2D to
//    Physics, and use rb.linearVelocity with Vector3
// ============================================================</code></pre>

            <h3>Common Issues</h3>
            <p><strong>"The dash feels weak"</strong><br>
            Increase <code>dashSpeed</code>. Dash should feel noticeably faster than running.</p>

            <p><strong>"I can't control where I'm going"</strong><br>
            Check <code>dashDirection</code>. If set to four-way, you might expect eight. Also check input handling for diagonals.</p>

            <p><strong>"The dash is too short/long"</strong><br>
            Adjust <code>dashDuration</code>. 0.1-0.2 is typical. Shorter = snappier; longer = more distance.</p>

            <p><strong>"It feels like I have infinite dashes"</strong><br>
            Check <code>refreshOnGround</code> and <code>dashCount</code>. If grounded resets dash instantly, add a brief window.</p>

            <p><strong>"I'm taking damage during dash"</strong><br>
            <code>invincibleDuringDash</code> needs to be true, and your damage system needs to check for invincibility frames.</p>

            <h3>Direction Systems</h3>
            <table>
              <thead>
                <tr>
                  <th>System</th>
                  <th>Directions</th>
                  <th>Use Case</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>FourWay</strong></td>
                  <td>Up, Down, Left, Right</td>
                  <td>Simple, classic</td>
                </tr>
                <tr>
                  <td><strong>EightWay</strong></td>
                  <td>+ Diagonals</td>
                  <td>Precise, modern platformers</td>
                </tr>
                <tr>
                  <td><strong>Horizontal</strong></td>
                  <td>Left, Right only</td>
                  <td>Ground-focused videogames</td>
                </tr>
                <tr>
                  <td><strong>Aim-Based</strong></td>
                  <td>Follows mouse/stick direction</td>
                  <td>Twin-stick, shooters</td>
                </tr>
                <tr>
                  <td><strong>Movement-Based</strong></td>
                  <td>Follows current velocity</td>
                  <td>Momentum-focused</td>
                </tr>
              </tbody>
            </table>

            <h3>Combine With</h3>
            <ul>
              <li><a href="air-control.html">Air Control</a> - what you can do after the dash</li>
              <li><a href="coyote-time.html">Coyote Time</a> - brief dash window after leaving platform</li>
              <li><a href="hitstop.html">Hitstop</a> - freeze when dash-attack connects</li>
              <li><a href="trail-effect.html">Trail Effect</a> - ghost images during dash</li>
              <li><a href="screen-shake.html">Screen Shake</a> - on dash-attack impact</li>
            </ul>
          </div>
        </div>

        <!-- CRAFT REGISTER -->
        <div class="register register--craft collapsed">
          <div class="register-header" onclick="this.parentElement.classList.toggle('collapsed')">
            Craft <span class="register-label">- for educators</span>
          </div>
          <div class="register-content">
            <h3>Why Teach Dash</h3>
            <p>Dash introduces students to <strong>resource management in movement</strong>. Unlike jump (which is almost always available), dash often has a count or cooldown. This creates decisions: "Should I dash now or save it?"</p>

            <h3>Teaching Sequence</h3>
            <ol>
              <li>Start with unlimited dashes, no cooldown - feel the basic mechanic</li>
              <li>Add dashCount = 1 with refreshOnGround - introduces resource thinking</li>
              <li>Add invincibility - changes how dash is used (evasion vs. movement)</li>
              <li>Experiment with direction systems</li>
            </ol>

            <h3>Common Student Mistakes</h3>
            <p><strong>Making dash too similar to running:</strong> If dash speed is only 1.5x run speed, it doesn't feel special. It needs to feel like a distinct mode.</p>

            <p><strong>Forgetting cancel windows:</strong> Students implement dash that can't be interrupted. This feels unresponsive. Even committed dashes usually have late cancel windows.</p>

            <p><strong>Ignoring the resource:</strong> When dashCount is treated as infinite, students miss the design opportunity. One dash per airtime creates meaningful choices.</p>

            <h3>Assessment</h3>
            <ul>
              <li>Can they articulate why Celeste uses one dash per airtime?</li>
              <li>Can they explain how invincibility changes the dash's role?</li>
              <li>Can they design a dash that fits a specific videogame genre?</li>
            </ul>

            <h3>Exercise: Dash Role Analysis</h3>
            <p>Have students play three videogames with dashes (Celeste, Hades, Mega Man X). For each:</p>
            <ul>
              <li>What role does the dash serve? (Traversal? Evasion? Combat?)</li>
              <li>How does the resource system support that role?</li>
              <li>What would change if you removed dash invincibility?</li>
            </ul>
          </div>
        </div>

        <!-- THEORY REGISTER -->
        <div class="register register--theory collapsed">
          <div class="register-header" onclick="this.parentElement.classList.toggle('collapsed')">
            Theory <span class="register-label">- deeper grounding</span>
          </div>
          <div class="register-content">
            <h3>Heritage Notes</h3>
            <p>The dash evolved from several sources:</p>

            <p><strong>Mega Man X (1993)</strong> - Ground dash that changed the pace of action platformers. Made movement itself feel aggressive.</p>

            <p><strong>Fighting games</strong> - Air dashes in <em>Marvel vs. Capcom</em>, <em>Guilty Gear</em> created aerial mobility that felt distinct from jumping.</p>

            <p><strong>Modern platformers</strong> - <em>Celeste</em> refined the single-dash-per-air model into a precise tool.</p>

            <p>The dash is now so standard that its <em>absence</em> is notable. A platformer without dash feels deliberately retro.</p>

            <h3>Dash as Commitment</h3>
            <p>Dash represents a design philosophy: <strong>powerful but costly</strong>. Unlike jump (low commitment, low power), dash trades control for speed. You're locked into a direction.</p>

            <p>This connects to <a href="../framework/permissions.html" class="term">Permissions</a>: dash <em>allows</em> burst movement but <em>requires</em> commitment. It <em>forbids</em> changing direction mid-dash. The permissions shape the feel.</p>

            <h3>The Invincibility Question</h3>
            <p>Adding invincibility to dash transforms it from <em>movement tool</em> to <em>survival tool</em>. This changes everything:</p>
            <ul>
              <li>Players dash <em>through</em> attacks, not around them</li>
              <li>Dash timing becomes a core skill</li>
              <li>Enemy design must account for i-frames</li>
            </ul>
            <p>The decision to include invincibility is one of the most impactful in action videogame design.</p>

            <h3>The Celeste Model</h3>
            <p><em>Celeste</em> made the dash-per-airtime model canonical for precision platformers. Key insights:</p>
            <ul>
              <li>One dash per air period creates meaningful scarcity</li>
              <li>Eight directions enables precise positioning</li>
              <li>Refreshing on ground makes failure recoverable</li>
              <li>Brief invincibility forgives close calls</li>
            </ul>
            <p>This model is now the default expectation. Deviating from it is a deliberate choice.</p>

            <h3>Unresolved Questions</h3>
            <ul>
              <li>How much should momentum carry after dash? Full stop vs. smooth transition creates very different feels.</li>
              <li>Should dash refresh on other surfaces (walls, enemies)? Each refresh point changes level design possibilities.</li>
              <li>Is the Celeste model becoming too dominant? Are we losing variety in dash design?</li>
            </ul>
          </div>
        </div>

        <hr>

        <h2>Related</h2>
        <ul>
          <li><a href="../framework/gesture.html">Gesture</a> - dash as canonical gesture</li>
          <li><a href="../framework/aesthetic-heritage.html">Aesthetic Heritage</a> - dash lineage</li>
          <li><a href="trail-effect.html">Trail Effect</a> - common visual pairing</li>
        </ul>

        <h2>Glossary Terms</h2>
        <ul>
          <li><a href="../glossary.html#invincibility-frames" class="term">Invincibility Frames</a> - damage immunity period</li>
          <li><a href="../glossary.html#cancel-window" class="term">Cancel Window</a> - when you can interrupt an action</li>
          <li><a href="../glossary.html#juice" class="term">Juice</a> - feedback techniques that make dash feel powerful</li>
        </ul>

      </div>
    </main>
  </div>

  <script src="../../js/main.js"></script>
</body>
</html>
